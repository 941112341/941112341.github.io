(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{492:function(t,_,v){"use strict";v.r(_);var a=v(4),e=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"同步和半同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同步和半同步"}},[t._v("#")]),t._v(" 同步和半同步")]),t._v(" "),v("blockquote",[v("p",[t._v("同步：每次事务commit 后，不接受slave的ack\n半同步:master会等slave 接收到的事务进入 enqueue队列的ack，再进入下一步")])]),t._v(" "),v("h2",{attrs:{id:"dbatman-分片"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dbatman-分片"}},[t._v("#")]),t._v(" Dbatman 分片")]),t._v(" "),v("p",[t._v("需要找准分片列")]),t._v(" "),v("ul",[v("li",[t._v("update/insert 需要带分片列")]),t._v(" "),v("li",[t._v("不支持分片事务写，但支持事务读")]),t._v(" "),v("li",[t._v("直接更新分片列是不允许的")])]),t._v(" "),v("h2",{attrs:{id:"日志"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#日志"}},[t._v("#")]),t._v(" 日志")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("名字")]),t._v(" "),v("th",[t._v("作用")]),t._v(" "),v("th",[t._v("发生时间")]),t._v(" "),v("th",[t._v("相关参数")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("redo")]),t._v(" "),v("td",[t._v("确保事务持久性，脏页未写入磁盘就发生重启，记录了物理信息，页的修改")]),t._v(" "),v("td",[t._v("事务开始时，每次执行sql都会进行记录，不需要提交")]),t._v(" "),v("td",[t._v("innodb_log_file_size重做日志大小,Innodb_log_buffer日志缓冲，每次执行会先写入buffer，每次commit必定刷新到日志文件 or buffer不足 or master 每秒刷新")])]),t._v(" "),v("tr",[v("td",[t._v("undo")]),t._v(" "),v("td",[t._v("提供MVCC多版本并发控制读，保存了事务前一个版本的snapshot，用于实现隔离性，放的是逻辑日志，同样也会异步清理，一般只保存上个事务版本")]),t._v(" "),v("td",[t._v("需要独立的表空间")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("binlog")]),t._v(" "),v("td",[t._v("也是逻辑日志，用于主从复制，只包括增删改，并且可以用于时间点的还原")]),t._v(" "),v("td",[t._v("事务提交的时候将sql都刷入")]),t._v(" "),v("td",[t._v("二阶段提交，commit时需要先写redo log 再写 binlog才算真正成功")])])])])])}),[],!1,null,null,null);_.default=e.exports}}]);