(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{491:function(t,_,v){"use strict";v.r(_);var a=v(4),e=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"mysql分布式事务实现原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql分布式事务实现原理"}},[t._v("#")]),t._v(" MySQL分布式事务实现原理")]),t._v(" "),v("h2",{attrs:{id:"概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),v("ul",[v("li",[t._v("TCC(Try-Confirm-Cancel)事务，在第一阶段尝试预留变更需要的所有资源（prepare），根据第一阶段的结果，第二阶段对预留的资源进行操作（提交）或者释放预留的资源（回滚）。")]),t._v(" "),v("li",[t._v("SAGA事务，每个参与者都定义一个正向行为（变更）和一个反向行为（补偿），分布式事务按照既定顺序执行正向行为直到全部成功（提交），如果中间发生错误，则逆序执行对应的反向行为（回滚）。")])]),t._v(" "),v("h2",{attrs:{id:"架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#架构"}},[t._v("#")]),t._v(" 架构")]),t._v(" "),v("h2",{attrs:{id:"流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[t._v("#")]),t._v(" 流程")]),t._v(" "),v("blockquote",[v("p",[t._v("分支视角")])]),t._v(" "),v("ol",{attrs:{start:"0"}},[v("li",[v("p",[t._v("开启事务，获取唯一事务id，流转到rpc中")])]),t._v(" "),v("li",[v("p",[t._v("SQL是否是update/insert?")])])]),t._v(" "),v("p",[t._v("1.1 否：直接执行")]),t._v(" "),v("p",[t._v("1.2 是：先执行select * for update 锁住记录，where语法需要构造，构成beforeImage")]),t._v(" "),v("p",[t._v("1.3 处理语句，只执行，不进行提交")]),t._v(" "),v("p",[t._v("1.4 select * .. where pk = ? and sharding_key= ? 根据id搜索出结果afterImage")]),t._v(" "),v("p",[t._v("1.5 保存image")]),t._v(" "),v("p",[t._v("2 构造全局锁 （db_table_pk_shardkey）")]),t._v(" "),v("p",[t._v("2.1 注册全局锁，\n2.1.1 为何会冲突？因为下一步马上就是提交，提交之后锁失效")]),t._v(" "),v("p",[t._v("2.2 注册成功后返回分支事务id，写入事务表")]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("执行下一节点，执行失败前面陆续回滚")])]),t._v(" "),v("blockquote",[v("p",[t._v("总TC（事务管理器视角）")])]),t._v(" "),v("p",[t._v("当接收到了代码提交请求")]),t._v(" "),v("ol",[v("li",[t._v("更新全局事务表状态")]),t._v(" "),v("li",[t._v("请求进入内存 （为了异步清楚），返回提交成功")]),t._v(" "),v("li",[t._v("删除全局锁 / 清理undoLog表")])]),t._v(" "),v("p",[t._v("接收到 回顾的请求进行逆向操作即可")]),t._v(" "),v("h2",{attrs:{id:"问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),v("p",[t._v("可能会脏读，因为前一个节点的数据可能将会回滚。\n解决部分方案：使用cas，尽量带上原值进行update")]),t._v(" "),v("h2",{attrs:{id:"性能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#性能"}},[t._v("#")]),t._v(" 性能")]),t._v(" "),v("p",[t._v("和TCC模式的对比")]),t._v(" "),v("ul",[v("li",[t._v("在事务提交的场景下，ByteTx的AT模式的性能，和业务实现的TCC模式事务（最简模式）相比，性能在伯仲之间。")]),t._v(" "),v("li",[t._v("在事务回滚的场景下，ByteTx的AT模式事务比业务实现的TCC模式事务（最简模式）有大约30%的性能下降。")]),t._v(" "),v("li",[t._v("在并发无热点的场景下，ByteTx的AT模式保持较好的性能，因为各服务节点的无状态部署以及数据库的分布式部署。")]),t._v(" "),v("li",[t._v("在并发且热点较多的场景下，ByteTx的AT模式性能较低，这种场景下不适用。\n此性能对比可以使用简单举例获取")])]),t._v(" "),v("p",[t._v("关键在于：更新操作次数 * 锁时间")])])}),[],!1,null,null,null);_.default=e.exports}}]);